1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
21 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memset 288
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
22 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memset 288
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
23 ../data/NVD/CVE_2013_0851_PATCHED_decode_frame.c memset 55
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 26 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
24 ../data/NVD/CVE_2013_0851_VULN_decode_frame.c memset 55
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 17 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
25 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 283
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
26 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 120
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
syslog ( LOG_ERR , "malloc failed" ); 120
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
27 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 117
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
28 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 89
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
syslog ( LOG_WARNING , "Received packet from untrusted pid:%u" , addr . nl_pid ); 89
------------------------------
29 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
30 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 64
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
31 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 44
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
32 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 33
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
33 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 27
int CVE_2012_5532_PATCHED_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
34 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 20
int CVE_2012_5532_PATCHED_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
35 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 277
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
36 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 114
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
syslog ( LOG_ERR , "malloc failed" ); 114
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
37 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 111
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
38 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
39 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 64
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
40 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 44
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
41 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 33
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
42 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 27
int CVE_2012_5532_VULN_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
43 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 20
int CVE_2012_5532_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
44 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcsncpy 24
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
45 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcsncpy 20
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
46 ../data/NVD/CVE_2013_0799_PATCHED_IsStatusApplying.c wcsncpy 6
static BOOL
CVE_2013_0799_PATCHED_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = L '\0' 5
wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
47 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
48 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
49 ../data/NVD/CVE_2012_5532_PATCHED_main.c strerror 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
50 ../data/NVD/CVE_2012_5532_VULN_main.c strerror 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
51 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
52 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
53 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
54 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
55 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
56 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
57 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
58 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
59 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
60 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
61 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
62 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
63 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 236
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
proto_tree * hsrp_tree = NULL ; 114
guint8 type , len ; 115
if ( tree )  119
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 120
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 121
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
proto_tree * text_auth_tlv ; 224
gchar auth_buf [ 8 + 1 ] ; 225
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
------------------------------
64 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
65 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 231
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
proto_tree * hsrp_tree = NULL ; 112
guint8 type , len ; 113
if ( tree )  117
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 118
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 119
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
proto_tree * text_auth_tlv ; 219
gchar auth_buf [ 8 + 1 ] ; 220
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 222
offset += 2; 224
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 227
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
------------------------------
66 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
67 ../data/NVD/CVE_2012_5532_PATCHED_main.c strlen 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
68 ../data/NVD/CVE_2012_5532_VULN_main.c strlen 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
69 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c strlen 45
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
* pbuffer = av_mallocz ( 2048 ); 36
return strlen ( * pbuffer ) ; 45
------------------------------
70 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c strlen 43
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
* pbuffer = av_mallocz ( 2048 ); 34
return strlen ( * pbuffer ) ; 43
------------------------------
71 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 166
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
72 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 147
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
free ( if_name ); 147
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
73 ../data/NVD/CVE_2012_5532_VULN_main.c free 160
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
74 ../data/NVD/CVE_2012_5532_VULN_main.c free 141
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
free ( if_name ); 141
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
75 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c strncpy 12
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
76 ../data/NVD/CVE_2013_0799_VULN_GetInstallationDir.c wcscpy 7
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
if ( argcTmp < 2 )  4
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
------------------------------
77 ../data/NVD/CVE_2013_0799_VULN_IsStatusApplying.c wcscpy 6
static BOOL
CVE_2013_0799_VULN_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; 5
wcscpy ( updateStatusFilePath , updateDirPath ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
78 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
79 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
80 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
81 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
82 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
83 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
84 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
85 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
86 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 36
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
87 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 30
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
88 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 21
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
------------------------------
89 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 37
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
90 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 31
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
91 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 22
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
------------------------------
92 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memcpy 129
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  19
tun = __tun_get ( tfile ); 30
if ( cmd == TUNSETIFF && ! tun )  31
if ( ! tun )  45
switch ( cmd )  51
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 129
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 130
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  131
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 138
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 140
return ret ; 206
------------------------------
93 ../data/NVD/CVE_2012_6547_VULN___tun_chr_ioctl.c memcpy 127
static long CVE_2012_6547_VULN___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  17
tun = __tun_get ( tfile ); 28
if ( cmd == TUNSETIFF && ! tun )  29
if ( ! tun )  43
switch ( cmd )  49
if ( arg )  72
tun -> flags &= ~TUN_PERSIST; 75
tun -> owner = ( uid_t ) arg; 83
tun -> group = ( gid_t ) arg; 90
if ( tun -> dev -> flags & IFF_UP )  97
tun -> dev -> type = ( int ) arg; 102
tun -> debug = arg; 110
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 127
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 128
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  129
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 136
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 138
return ret ; 204
------------------------------
1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
21 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memset 288
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
22 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memset 288
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
23 ../data/NVD/CVE_2013_0851_PATCHED_decode_frame.c memset 55
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 26 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
24 ../data/NVD/CVE_2013_0851_VULN_decode_frame.c memset 55
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 17 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
25 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 283
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
26 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 120
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
syslog ( LOG_ERR , "malloc failed" ); 120
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
27 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 117
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
28 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 89
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
syslog ( LOG_WARNING , "Received packet from untrusted pid:%u" , addr . nl_pid ); 89
------------------------------
29 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
30 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 64
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
31 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 44
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
32 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 33
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
33 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 27
int CVE_2012_5532_PATCHED_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
34 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 20
int CVE_2012_5532_PATCHED_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
35 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 277
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
36 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 114
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
syslog ( LOG_ERR , "malloc failed" ); 114
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
37 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 111
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
38 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
39 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 64
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
40 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 44
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
41 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 33
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
42 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 27
int CVE_2012_5532_VULN_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
43 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 20
int CVE_2012_5532_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
44 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcsncpy 24
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
45 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcsncpy 20
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
46 ../data/NVD/CVE_2013_0799_PATCHED_IsStatusApplying.c wcsncpy 6
static BOOL
CVE_2013_0799_PATCHED_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = L '\0' 5
wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
47 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
48 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
49 ../data/NVD/CVE_2012_5532_PATCHED_main.c strerror 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
50 ../data/NVD/CVE_2012_5532_VULN_main.c strerror 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
51 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
52 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
53 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
54 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
55 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
56 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
57 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
58 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
59 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
60 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
61 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
62 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
63 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 236
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
proto_tree * hsrp_tree = NULL ; 114
guint8 type , len ; 115
if ( tree )  119
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 120
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 121
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
proto_tree * text_auth_tlv ; 224
gchar auth_buf [ 8 + 1 ] ; 225
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
------------------------------
64 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
65 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 231
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
proto_tree * hsrp_tree = NULL ; 112
guint8 type , len ; 113
if ( tree )  117
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 118
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 119
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
proto_tree * text_auth_tlv ; 219
gchar auth_buf [ 8 + 1 ] ; 220
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 222
offset += 2; 224
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 227
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
------------------------------
66 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
67 ../data/NVD/CVE_2012_5532_PATCHED_main.c strlen 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
68 ../data/NVD/CVE_2012_5532_VULN_main.c strlen 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
69 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c strlen 45
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
* pbuffer = av_mallocz ( 2048 ); 36
return strlen ( * pbuffer ) ; 45
------------------------------
70 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c strlen 43
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
* pbuffer = av_mallocz ( 2048 ); 34
return strlen ( * pbuffer ) ; 43
------------------------------
71 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 166
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
72 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 147
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
free ( if_name ); 147
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
73 ../data/NVD/CVE_2012_5532_VULN_main.c free 160
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
74 ../data/NVD/CVE_2012_5532_VULN_main.c free 141
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
free ( if_name ); 141
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
75 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c strncpy 12
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
76 ../data/NVD/CVE_2013_0799_VULN_GetInstallationDir.c wcscpy 7
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
if ( argcTmp < 2 )  4
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
------------------------------
77 ../data/NVD/CVE_2013_0799_VULN_IsStatusApplying.c wcscpy 6
static BOOL
CVE_2013_0799_VULN_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; 5
wcscpy ( updateStatusFilePath , updateDirPath ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
78 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
79 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
80 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
81 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
82 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
83 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
84 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
85 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
86 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 36
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
87 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 30
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
88 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 21
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
------------------------------
89 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 37
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
90 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 31
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
91 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 22
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
------------------------------
92 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memcpy 129
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  19
tun = __tun_get ( tfile ); 30
if ( cmd == TUNSETIFF && ! tun )  31
if ( ! tun )  45
switch ( cmd )  51
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 129
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 130
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  131
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 138
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 140
return ret ; 206
------------------------------
93 ../data/NVD/CVE_2012_6547_VULN___tun_chr_ioctl.c memcpy 127
static long CVE_2012_6547_VULN___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  17
tun = __tun_get ( tfile ); 28
if ( cmd == TUNSETIFF && ! tun )  29
if ( ! tun )  43
switch ( cmd )  49
if ( arg )  72
tun -> flags &= ~TUN_PERSIST; 75
tun -> owner = ( uid_t ) arg; 83
tun -> group = ( gid_t ) arg; 90
if ( tun -> dev -> flags & IFF_UP )  97
tun -> dev -> type = ( int ) arg; 102
tun -> debug = arg; 110
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 127
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 128
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  129
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 136
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 138
return ret ; 204
------------------------------
94 ../data/NVD/CVE_2013_0772_PATCHED_nsGIFDecoder2__OutputRow.c memcpy 66
uint32_t CVE_2013_0772_PATCHED_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  62
for (int r = drow_start; r <= drow_end; r++) 64
if ( r != int ( mGIFStruct . irow ) )  65
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 66
------------------------------
95 ../data/NVD/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c memcpy 74
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  70
for (int r = drow_start; r <= drow_end; r++) 72
if ( r != int ( mGIFStruct . irow ) )  73
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 74
------------------------------
96 ../data/NVD/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c memcpy 29
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* outString = temp; 22
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
------------------------------
97 ../data/NVD/CVE_2013_0782_VULN_nsSaveAsCharset__HandleFallBack.c memcpy 27
NS_IMETHODIMP
CVE_2013_0782_VULN_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + tempLen ) ; 16
if ( temp )  17
* outString = temp; 20
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 27
------------------------------
98 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memcpy 287
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
99 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memcpy 287
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
100 ../data/NVD/CVE_2013_0856_PATCHED_lpc_prediction.c memcpy 15
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
101 ../data/NVD/CVE_2013_0856_VULN_lpc_prediction.c memcpy 15
static void CVE_2013_0856_VULN_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
102 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 84
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
------------------------------
103 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 65
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
104 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 45
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
105 ../data/NVD/CVE_2012_5532_VULN_main.c close 84
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
------------------------------
106 ../data/NVD/CVE_2012_5532_VULN_main.c close 65
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
107 ../data/NVD/CVE_2012_5532_VULN_main.c close 45
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
108 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strchr 22
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
109 ../data/NVD/CVE_2012_4530_VULN_load_script.c strchr 22
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
110 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 164
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
assert ( 0 && "unexpected colorspace" ); 164
------------------------------
111 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 139
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  137
assert ( 0 && "input type" ); 139
------------------------------
112 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 67
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  65
assert ( 0 && "input type" ); 67
------------------------------
113 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 37
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 35
if ( ! result )  36
assert ( 0 && "precacheLUT failed" ); 37
------------------------------
114 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
115 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 160
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
assert ( 0 && "unexpected colorspace" ); 160
------------------------------
116 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 135
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  133
assert ( 0 && "input type" ); 135
------------------------------
117 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 63
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  61
assert ( 0 && "input type" ); 63
------------------------------
118 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 33
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 31
if ( ! result )  32
assert ( 0 && "precacheLUT failed" ); 33
------------------------------
119 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
120 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 520
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
121 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 510
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
122 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 469
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
123 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 468
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
124 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 467
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
125 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 372
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
126 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 371
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
127 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 370
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
128 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 520
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
129 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 510
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
130 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 469
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
131 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 468
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
132 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 467
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
133 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 372
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
134 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 371
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
135 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 370
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
136 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 360
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 360
------------------------------
137 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 359
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 359
------------------------------
138 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 358
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr ); 358
------------------------------
139 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 261
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 261
------------------------------
140 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 260
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 260
------------------------------
141 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 259
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr ); 259
------------------------------
142 ../data/NVD/CVE_2012_5532_PATCHED_main.c malloc 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
143 ../data/NVD/CVE_2012_5532_VULN_main.c malloc 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
144 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
145 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
146 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 109
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
------------------------------
147 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
148 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 107
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
------------------------------
149 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
150 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
151 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
152 ../data/NVD/CVE_2012_5532_PATCHED_main.c socket 31
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
switch ( op )  125
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 223
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
strcpy ( key_name , "NetworkAddressIPv4" ); 234
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_value , os_build ); 242
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_value , os_name ); 246
strcpy ( key_name , "OSName" ); 247
strcpy ( key_value , os_major ); 250
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_value , os_minor ); 254
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_value , os_build ); 258
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_value , processor_arch ); 262
strcpy ( key_name , "ProcessorArchitecture" ); 263
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
153 ../data/NVD/CVE_2012_5532_VULN_main.c socket 31
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
switch ( op )  119
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 217
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
strcpy ( key_name , "NetworkAddressIPv4" ); 228
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_value , os_build ); 236
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_value , os_name ); 240
strcpy ( key_name , "OSName" ); 241
strcpy ( key_value , os_major ); 244
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_value , os_minor ); 248
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_value , os_build ); 252
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_value , processor_arch ); 256
strcpy ( key_name , "ProcessorArchitecture" ); 257
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
154 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strcpy 43
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
155 ../data/NVD/CVE_2012_4530_VULN_load_script.c strcpy 43
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
156 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 263
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
157 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 262
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
158 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 259
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
159 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 258
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
160 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 255
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
161 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 254
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
162 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 251
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
163 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 250
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
164 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 247
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
165 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 246
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
166 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 243
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
167 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 242
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
168 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 239
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
169 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 234
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
170 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 229
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
171 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 228
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
172 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 225
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
173 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 116
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
174 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 257
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
175 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 256
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
176 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 253
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
177 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 252
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
178 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 249
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
179 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 248
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
180 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 245
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
181 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 244
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
182 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 241
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
183 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 240
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
184 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 237
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
185 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 236
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
186 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 233
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
187 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 228
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
188 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 223
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
189 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 222
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
190 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 219
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
191 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 110
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
192 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c strcpy 12
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
193 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c LoadLibraryW 32
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
systemDirectory [ systemDirLen + fileLen ] = L '\0' 27
systemDirectory [ MAX_PATH ] = L '\0' 29
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
194 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c LoadLibraryW 28
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
systemDirectory [ systemDirLen + fileLen ] = L '\0' 23
systemDirectory [ MAX_PATH ] = L '\0' 25
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
195 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 23
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
if ( systemDirLen + fileLen <= MAX_PATH )  26
------------------------------
196 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 12
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
197 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 19
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
if ( systemDirLen + fileLen <= MAX_PATH )  22
------------------------------
198 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 8
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
199 ../data/NVD/CVE_2012_5532_PATCHED_main.c recvfrom 78
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
200 ../data/NVD/CVE_2012_5532_VULN_main.c recvfrom 78
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
21 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memset 288
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
22 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memset 288
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
23 ../data/NVD/CVE_2013_0851_PATCHED_decode_frame.c memset 55
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 26 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
24 ../data/NVD/CVE_2013_0851_VULN_decode_frame.c memset 55
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 17 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
25 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 283
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
26 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 120
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
syslog ( LOG_ERR , "malloc failed" ); 120
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
27 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 117
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
28 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 89
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
syslog ( LOG_WARNING , "Received packet from untrusted pid:%u" , addr . nl_pid ); 89
------------------------------
29 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
30 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 64
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
31 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 44
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
32 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 33
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
33 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 27
int CVE_2012_5532_PATCHED_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
34 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 20
int CVE_2012_5532_PATCHED_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
35 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 277
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
36 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 114
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
syslog ( LOG_ERR , "malloc failed" ); 114
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
37 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 111
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
38 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
39 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 64
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
40 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 44
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
41 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 33
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
42 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 27
int CVE_2012_5532_VULN_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
43 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 20
int CVE_2012_5532_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
44 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcsncpy 24
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
45 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcsncpy 20
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
46 ../data/NVD/CVE_2013_0799_PATCHED_IsStatusApplying.c wcsncpy 6
static BOOL
CVE_2013_0799_PATCHED_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = L '\0' 5
wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
47 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
48 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
49 ../data/NVD/CVE_2012_5532_PATCHED_main.c strerror 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
50 ../data/NVD/CVE_2012_5532_VULN_main.c strerror 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
51 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
52 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
53 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
54 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
55 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
56 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
57 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
58 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
59 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
60 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
61 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
62 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
63 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 236
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
proto_tree * hsrp_tree = NULL ; 114
guint8 type , len ; 115
if ( tree )  119
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 120
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 121
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
proto_tree * text_auth_tlv ; 224
gchar auth_buf [ 8 + 1 ] ; 225
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
------------------------------
64 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
65 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 231
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
proto_tree * hsrp_tree = NULL ; 112
guint8 type , len ; 113
if ( tree )  117
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 118
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 119
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
proto_tree * text_auth_tlv ; 219
gchar auth_buf [ 8 + 1 ] ; 220
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 222
offset += 2; 224
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 227
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
------------------------------
66 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
67 ../data/NVD/CVE_2012_5532_PATCHED_main.c strlen 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
68 ../data/NVD/CVE_2012_5532_VULN_main.c strlen 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
69 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c strlen 45
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
* pbuffer = av_mallocz ( 2048 ); 36
return strlen ( * pbuffer ) ; 45
------------------------------
70 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c strlen 43
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
* pbuffer = av_mallocz ( 2048 ); 34
return strlen ( * pbuffer ) ; 43
------------------------------
71 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 166
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
72 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 147
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
free ( if_name ); 147
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
73 ../data/NVD/CVE_2012_5532_VULN_main.c free 160
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
74 ../data/NVD/CVE_2012_5532_VULN_main.c free 141
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
free ( if_name ); 141
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
75 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c strncpy 12
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
76 ../data/NVD/CVE_2013_0799_VULN_GetInstallationDir.c wcscpy 7
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
if ( argcTmp < 2 )  4
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
------------------------------
77 ../data/NVD/CVE_2013_0799_VULN_IsStatusApplying.c wcscpy 6
static BOOL
CVE_2013_0799_VULN_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; 5
wcscpy ( updateStatusFilePath , updateDirPath ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
78 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
79 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
80 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
81 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
82 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
83 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
84 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
85 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
86 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 36
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
87 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 30
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
88 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 21
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
------------------------------
89 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 37
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
90 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 31
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
91 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 22
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
------------------------------
92 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memcpy 129
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  19
tun = __tun_get ( tfile ); 30
if ( cmd == TUNSETIFF && ! tun )  31
if ( ! tun )  45
switch ( cmd )  51
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 129
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 130
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  131
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 138
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 140
return ret ; 206
------------------------------
93 ../data/NVD/CVE_2012_6547_VULN___tun_chr_ioctl.c memcpy 127
static long CVE_2012_6547_VULN___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  17
tun = __tun_get ( tfile ); 28
if ( cmd == TUNSETIFF && ! tun )  29
if ( ! tun )  43
switch ( cmd )  49
if ( arg )  72
tun -> flags &= ~TUN_PERSIST; 75
tun -> owner = ( uid_t ) arg; 83
tun -> group = ( gid_t ) arg; 90
if ( tun -> dev -> flags & IFF_UP )  97
tun -> dev -> type = ( int ) arg; 102
tun -> debug = arg; 110
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 127
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 128
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  129
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 136
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 138
return ret ; 204
------------------------------
94 ../data/NVD/CVE_2013_0772_PATCHED_nsGIFDecoder2__OutputRow.c memcpy 66
uint32_t CVE_2013_0772_PATCHED_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  62
for (int r = drow_start; r <= drow_end; r++) 64
if ( r != int ( mGIFStruct . irow ) )  65
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 66
------------------------------
95 ../data/NVD/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c memcpy 74
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  70
for (int r = drow_start; r <= drow_end; r++) 72
if ( r != int ( mGIFStruct . irow ) )  73
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 74
------------------------------
96 ../data/NVD/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c memcpy 29
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* outString = temp; 22
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
------------------------------
97 ../data/NVD/CVE_2013_0782_VULN_nsSaveAsCharset__HandleFallBack.c memcpy 27
NS_IMETHODIMP
CVE_2013_0782_VULN_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + tempLen ) ; 16
if ( temp )  17
* outString = temp; 20
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 27
------------------------------
98 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memcpy 287
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
99 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memcpy 287
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
100 ../data/NVD/CVE_2013_0856_PATCHED_lpc_prediction.c memcpy 15
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
101 ../data/NVD/CVE_2013_0856_VULN_lpc_prediction.c memcpy 15
static void CVE_2013_0856_VULN_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
102 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 84
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
------------------------------
103 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 65
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
104 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 45
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
105 ../data/NVD/CVE_2012_5532_VULN_main.c close 84
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
------------------------------
106 ../data/NVD/CVE_2012_5532_VULN_main.c close 65
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
107 ../data/NVD/CVE_2012_5532_VULN_main.c close 45
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
108 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strchr 22
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
109 ../data/NVD/CVE_2012_4530_VULN_load_script.c strchr 22
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
110 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 164
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
assert ( 0 && "unexpected colorspace" ); 164
------------------------------
111 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 139
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  137
assert ( 0 && "input type" ); 139
------------------------------
112 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 67
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  65
assert ( 0 && "input type" ); 67
------------------------------
113 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 37
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 35
if ( ! result )  36
assert ( 0 && "precacheLUT failed" ); 37
------------------------------
114 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
115 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 160
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
assert ( 0 && "unexpected colorspace" ); 160
------------------------------
116 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 135
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  133
assert ( 0 && "input type" ); 135
------------------------------
117 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 63
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  61
assert ( 0 && "input type" ); 63
------------------------------
118 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 33
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 31
if ( ! result )  32
assert ( 0 && "precacheLUT failed" ); 33
------------------------------
119 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
120 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 520
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
121 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 510
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
122 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 469
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
123 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 468
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
124 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 467
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
125 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 372
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
126 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 371
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
127 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 370
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
128 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 520
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
129 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 510
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
130 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 469
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
131 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 468
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
132 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 467
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
133 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 372
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
134 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 371
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
135 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 370
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
136 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 360
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 360
------------------------------
137 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 359
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 359
------------------------------
138 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 358
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr ); 358
------------------------------
139 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 261
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 261
------------------------------
140 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 260
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 260
------------------------------
141 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 259
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr ); 259
------------------------------
142 ../data/NVD/CVE_2012_5532_PATCHED_main.c malloc 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
143 ../data/NVD/CVE_2012_5532_VULN_main.c malloc 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
144 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
145 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
146 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 109
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
------------------------------
147 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
148 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 107
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
------------------------------
149 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
150 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
151 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
152 ../data/NVD/CVE_2012_5532_PATCHED_main.c socket 31
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
switch ( op )  125
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 223
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
strcpy ( key_name , "NetworkAddressIPv4" ); 234
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_value , os_build ); 242
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_value , os_name ); 246
strcpy ( key_name , "OSName" ); 247
strcpy ( key_value , os_major ); 250
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_value , os_minor ); 254
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_value , os_build ); 258
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_value , processor_arch ); 262
strcpy ( key_name , "ProcessorArchitecture" ); 263
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
153 ../data/NVD/CVE_2012_5532_VULN_main.c socket 31
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
switch ( op )  119
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 217
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
strcpy ( key_name , "NetworkAddressIPv4" ); 228
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_value , os_build ); 236
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_value , os_name ); 240
strcpy ( key_name , "OSName" ); 241
strcpy ( key_value , os_major ); 244
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_value , os_minor ); 248
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_value , os_build ); 252
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_value , processor_arch ); 256
strcpy ( key_name , "ProcessorArchitecture" ); 257
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
154 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strcpy 43
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
155 ../data/NVD/CVE_2012_4530_VULN_load_script.c strcpy 43
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
156 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 263
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
157 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 262
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
158 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 259
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
159 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 258
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
160 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 255
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
161 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 254
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
162 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 251
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
163 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 250
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
164 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 247
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
165 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 246
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
166 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 243
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
167 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 242
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
168 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 239
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
169 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 234
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
170 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 229
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
171 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 228
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
172 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 225
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
173 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 116
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
174 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 257
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
175 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 256
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
176 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 253
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
177 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 252
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
178 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 249
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
179 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 248
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
180 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 245
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
181 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 244
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
182 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 241
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
183 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 240
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
184 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 237
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
185 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 236
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
186 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 233
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
187 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 228
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
188 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 223
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
189 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 222
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
190 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 219
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
191 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 110
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
192 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c strcpy 12
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
193 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c LoadLibraryW 32
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
systemDirectory [ systemDirLen + fileLen ] = L '\0' 27
systemDirectory [ MAX_PATH ] = L '\0' 29
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
194 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c LoadLibraryW 28
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
systemDirectory [ systemDirLen + fileLen ] = L '\0' 23
systemDirectory [ MAX_PATH ] = L '\0' 25
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
195 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 23
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
if ( systemDirLen + fileLen <= MAX_PATH )  26
------------------------------
196 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 12
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
197 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 19
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
if ( systemDirLen + fileLen <= MAX_PATH )  22
------------------------------
198 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 8
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
199 ../data/NVD/CVE_2012_5532_PATCHED_main.c recvfrom 78
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
200 ../data/NVD/CVE_2012_5532_VULN_main.c recvfrom 78
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
21 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memset 288
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
22 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memset 288
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
23 ../data/NVD/CVE_2013_0851_PATCHED_decode_frame.c memset 55
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 26 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
24 ../data/NVD/CVE_2013_0851_VULN_decode_frame.c memset 55
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 17 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
25 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 283
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
26 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 120
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
syslog ( LOG_ERR , "malloc failed" ); 120
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
27 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 117
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
28 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 89
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
syslog ( LOG_WARNING , "Received packet from untrusted pid:%u" , addr . nl_pid ); 89
------------------------------
29 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
30 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 64
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
31 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 44
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
32 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 33
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
33 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 27
int CVE_2012_5532_PATCHED_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
34 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 20
int CVE_2012_5532_PATCHED_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
35 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 277
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
36 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 114
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
syslog ( LOG_ERR , "malloc failed" ); 114
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
37 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 111
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
38 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
39 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 64
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
40 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 44
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
41 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 33
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
42 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 27
int CVE_2012_5532_VULN_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
43 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 20
int CVE_2012_5532_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
44 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcsncpy 24
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
45 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcsncpy 20
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
46 ../data/NVD/CVE_2013_0799_PATCHED_IsStatusApplying.c wcsncpy 6
static BOOL
CVE_2013_0799_PATCHED_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = L '\0' 5
wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
47 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
48 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
49 ../data/NVD/CVE_2012_5532_PATCHED_main.c strerror 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
50 ../data/NVD/CVE_2012_5532_VULN_main.c strerror 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
51 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
52 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
53 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
54 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
55 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
56 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
57 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
58 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
59 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
60 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
61 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
62 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
63 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 236
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
proto_tree * hsrp_tree = NULL ; 114
guint8 type , len ; 115
if ( tree )  119
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 120
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 121
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
proto_tree * text_auth_tlv ; 224
gchar auth_buf [ 8 + 1 ] ; 225
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
------------------------------
64 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
65 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 231
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
proto_tree * hsrp_tree = NULL ; 112
guint8 type , len ; 113
if ( tree )  117
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 118
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 119
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
proto_tree * text_auth_tlv ; 219
gchar auth_buf [ 8 + 1 ] ; 220
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 222
offset += 2; 224
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 227
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
------------------------------
66 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
67 ../data/NVD/CVE_2012_5532_PATCHED_main.c strlen 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
68 ../data/NVD/CVE_2012_5532_VULN_main.c strlen 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
69 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c strlen 45
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
* pbuffer = av_mallocz ( 2048 ); 36
return strlen ( * pbuffer ) ; 45
------------------------------
70 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c strlen 43
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
* pbuffer = av_mallocz ( 2048 ); 34
return strlen ( * pbuffer ) ; 43
------------------------------
71 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 166
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
72 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 147
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
free ( if_name ); 147
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
73 ../data/NVD/CVE_2012_5532_VULN_main.c free 160
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
74 ../data/NVD/CVE_2012_5532_VULN_main.c free 141
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
free ( if_name ); 141
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
75 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c strncpy 12
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
76 ../data/NVD/CVE_2013_0799_VULN_GetInstallationDir.c wcscpy 7
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
if ( argcTmp < 2 )  4
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
------------------------------
77 ../data/NVD/CVE_2013_0799_VULN_IsStatusApplying.c wcscpy 6
static BOOL
CVE_2013_0799_VULN_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; 5
wcscpy ( updateStatusFilePath , updateDirPath ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
78 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
79 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
80 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
81 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
82 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
83 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
84 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
85 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
86 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 36
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
87 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 30
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
88 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 21
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
------------------------------
89 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 37
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
90 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 31
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
91 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 22
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
------------------------------
92 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memcpy 129
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  19
tun = __tun_get ( tfile ); 30
if ( cmd == TUNSETIFF && ! tun )  31
if ( ! tun )  45
switch ( cmd )  51
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 129
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 130
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  131
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 138
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 140
return ret ; 206
------------------------------
93 ../data/NVD/CVE_2012_6547_VULN___tun_chr_ioctl.c memcpy 127
static long CVE_2012_6547_VULN___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  17
tun = __tun_get ( tfile ); 28
if ( cmd == TUNSETIFF && ! tun )  29
if ( ! tun )  43
switch ( cmd )  49
if ( arg )  72
tun -> flags &= ~TUN_PERSIST; 75
tun -> owner = ( uid_t ) arg; 83
tun -> group = ( gid_t ) arg; 90
if ( tun -> dev -> flags & IFF_UP )  97
tun -> dev -> type = ( int ) arg; 102
tun -> debug = arg; 110
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 127
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 128
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  129
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 136
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 138
return ret ; 204
------------------------------
94 ../data/NVD/CVE_2013_0772_PATCHED_nsGIFDecoder2__OutputRow.c memcpy 66
uint32_t CVE_2013_0772_PATCHED_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  62
for (int r = drow_start; r <= drow_end; r++) 64
if ( r != int ( mGIFStruct . irow ) )  65
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 66
------------------------------
95 ../data/NVD/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c memcpy 74
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  70
for (int r = drow_start; r <= drow_end; r++) 72
if ( r != int ( mGIFStruct . irow ) )  73
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 74
------------------------------
96 ../data/NVD/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c memcpy 29
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* outString = temp; 22
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
------------------------------
97 ../data/NVD/CVE_2013_0782_VULN_nsSaveAsCharset__HandleFallBack.c memcpy 27
NS_IMETHODIMP
CVE_2013_0782_VULN_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + tempLen ) ; 16
if ( temp )  17
* outString = temp; 20
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 27
------------------------------
98 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memcpy 287
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
99 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memcpy 287
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
100 ../data/NVD/CVE_2013_0856_PATCHED_lpc_prediction.c memcpy 15
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
101 ../data/NVD/CVE_2013_0856_VULN_lpc_prediction.c memcpy 15
static void CVE_2013_0856_VULN_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
102 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 84
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
------------------------------
103 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 65
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
104 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 45
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
105 ../data/NVD/CVE_2012_5532_VULN_main.c close 84
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
------------------------------
106 ../data/NVD/CVE_2012_5532_VULN_main.c close 65
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
107 ../data/NVD/CVE_2012_5532_VULN_main.c close 45
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
108 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strchr 22
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
109 ../data/NVD/CVE_2012_4530_VULN_load_script.c strchr 22
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
110 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 164
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
assert ( 0 && "unexpected colorspace" ); 164
------------------------------
111 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 139
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  137
assert ( 0 && "input type" ); 139
------------------------------
112 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 67
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  65
assert ( 0 && "input type" ); 67
------------------------------
113 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 37
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 35
if ( ! result )  36
assert ( 0 && "precacheLUT failed" ); 37
------------------------------
114 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
115 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 160
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
assert ( 0 && "unexpected colorspace" ); 160
------------------------------
116 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 135
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  133
assert ( 0 && "input type" ); 135
------------------------------
117 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 63
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  61
assert ( 0 && "input type" ); 63
------------------------------
118 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 33
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 31
if ( ! result )  32
assert ( 0 && "precacheLUT failed" ); 33
------------------------------
119 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
120 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 520
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
121 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 510
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
122 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 469
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
123 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 468
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
124 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 467
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
125 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 372
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
126 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 371
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
127 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 370
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
128 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 520
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
129 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 510
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
130 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 469
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
131 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 468
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
132 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 467
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
133 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 372
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
134 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 371
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
135 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 370
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
136 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 360
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 360
------------------------------
137 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 359
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 359
------------------------------
138 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 358
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr ); 358
------------------------------
139 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 261
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 261
------------------------------
140 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 260
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 260
------------------------------
141 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 259
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr ); 259
------------------------------
142 ../data/NVD/CVE_2012_5532_PATCHED_main.c malloc 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
143 ../data/NVD/CVE_2012_5532_VULN_main.c malloc 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
144 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
145 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
146 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 109
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
------------------------------
147 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
148 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 107
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
------------------------------
149 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
150 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
151 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
152 ../data/NVD/CVE_2012_5532_PATCHED_main.c socket 31
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
switch ( op )  125
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 223
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
strcpy ( key_name , "NetworkAddressIPv4" ); 234
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_value , os_build ); 242
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_value , os_name ); 246
strcpy ( key_name , "OSName" ); 247
strcpy ( key_value , os_major ); 250
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_value , os_minor ); 254
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_value , os_build ); 258
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_value , processor_arch ); 262
strcpy ( key_name , "ProcessorArchitecture" ); 263
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
153 ../data/NVD/CVE_2012_5532_VULN_main.c socket 31
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
switch ( op )  119
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 217
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
strcpy ( key_name , "NetworkAddressIPv4" ); 228
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_value , os_build ); 236
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_value , os_name ); 240
strcpy ( key_name , "OSName" ); 241
strcpy ( key_value , os_major ); 244
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_value , os_minor ); 248
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_value , os_build ); 252
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_value , processor_arch ); 256
strcpy ( key_name , "ProcessorArchitecture" ); 257
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
154 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strcpy 43
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
155 ../data/NVD/CVE_2012_4530_VULN_load_script.c strcpy 43
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
156 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 263
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
157 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 262
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
158 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 259
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
159 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 258
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
160 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 255
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
161 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 254
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
162 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 251
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
163 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 250
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
164 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 247
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
165 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 246
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
166 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 243
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
167 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 242
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
168 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 239
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
169 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 234
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
170 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 229
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
171 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 228
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
172 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 225
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
173 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 116
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
174 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 257
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
175 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 256
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
176 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 253
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
177 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 252
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
178 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 249
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
179 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 248
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
180 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 245
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
181 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 244
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
182 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 241
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
183 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 240
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
184 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 237
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
185 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 236
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
186 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 233
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
187 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 228
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
188 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 223
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
189 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 222
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
190 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 219
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
191 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 110
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
192 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c strcpy 12
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
193 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c LoadLibraryW 32
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
systemDirectory [ systemDirLen + fileLen ] = L '\0' 27
systemDirectory [ MAX_PATH ] = L '\0' 29
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
194 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c LoadLibraryW 28
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
systemDirectory [ systemDirLen + fileLen ] = L '\0' 23
systemDirectory [ MAX_PATH ] = L '\0' 25
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
195 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 23
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
if ( systemDirLen + fileLen <= MAX_PATH )  26
------------------------------
196 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 12
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
197 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 19
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
if ( systemDirLen + fileLen <= MAX_PATH )  22
------------------------------
198 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 8
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
199 ../data/NVD/CVE_2012_5532_PATCHED_main.c recvfrom 78
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
200 ../data/NVD/CVE_2012_5532_VULN_main.c recvfrom 78
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
1 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
------------------------------
2 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
------------------------------
3 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
------------------------------
4 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
------------------------------
5 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
6 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
7 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
8 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
9 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
10 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
11 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
12 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
13 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
14 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
15 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
16 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
------------------------------
17 ../data/NVD/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
18 ../data/NVD/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
------------------------------
19 ../data/NVD/CVE_2013_0848_PATCHED_decode_init.c memset 6
static av_cold int CVE_2013_0848_PATCHED_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
if ( s -> predictor == MEDIAN && avctx -> pix_fmt == AV_PIX_FMT_YUV422P && avctx -> width % 4 )  99
alloc_temp ( s ); 103
------------------------------
20 ../data/NVD/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
------------------------------
21 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memset 288
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
22 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memset 288
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
23 ../data/NVD/CVE_2013_0851_PATCHED_decode_frame.c memset 55
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 26 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
24 ../data/NVD/CVE_2013_0851_VULN_decode_frame.c memset 55
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 17 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
------------------------------
25 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 283
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
26 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 120
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
syslog ( LOG_ERR , "malloc failed" ); 120
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
27 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 117
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
28 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 89
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
syslog ( LOG_WARNING , "Received packet from untrusted pid:%u" , addr . nl_pid ); 89
------------------------------
29 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
30 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 64
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
31 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 44
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
32 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 33
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
33 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 27
int CVE_2012_5532_PATCHED_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
34 ../data/NVD/CVE_2012_5532_PATCHED_main.c syslog 20
int CVE_2012_5532_PATCHED_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
35 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 277
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
36 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 114
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
syslog ( LOG_ERR , "malloc failed" ); 114
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
37 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 111
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
38 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
39 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 64
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
------------------------------
40 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 44
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
------------------------------
41 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 33
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
------------------------------
42 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 27
int CVE_2012_5532_VULN_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
------------------------------
43 ../data/NVD/CVE_2012_5532_VULN_main.c syslog 20
int CVE_2012_5532_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
------------------------------
44 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcsncpy 24
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
45 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcsncpy 20
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
46 ../data/NVD/CVE_2013_0799_PATCHED_IsStatusApplying.c wcsncpy 6
static BOOL
CVE_2013_0799_PATCHED_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] = L '\0' 5
wcsncpy ( updateStatusFilePath , updateDirPath , MAX_PATH ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
47 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
48 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
------------------------------
49 ../data/NVD/CVE_2012_5532_PATCHED_main.c strerror 82
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
50 ../data/NVD/CVE_2012_5532_VULN_main.c strerror 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
------------------------------
51 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
52 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
53 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
54 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
55 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
56 ../data/NVD/CVE_2012_6061_PATCHED_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
57 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 342
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
58 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 304
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
if ( tree )  155
fprintf ( stderr , "dissect_wtp: (4) tree was %p\n" , tree ); 304
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 342
------------------------------
59 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 169
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
60 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 168
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
61 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 162
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
62 ../data/NVD/CVE_2012_6061_VULN_dissect_wtp_common.c fprintf 157
static void
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offCur = 0 ; 5
unsigned char b0 ; 8
guint cbHeader = 0 ; 14
char pdut ; 22
b0 = tvb_get_guint8 ( tvb , offCur + 0 ); 35
if ( b0 == 0 )  37
pdut = pdu_type ( b0 ); 86
switch ( pdut )  100
cbHeader = 4; 109
cbHeader = 4; 122
cbHeader = 4; 126
cbHeader = 3; 133
cbHeader = 3; 137
numMissing = tvb_get_guint8 ( tvb , offCur + 3 ); 142
cbHeader = numMissing + 4; 143
if ( tree )  155
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 157
fprintf ( stderr , "dissect_wtp: (7) Returned from proto_tree_add_item\n" ); 162
fprintf ( stderr , "dissect_wtp: cbHeader = %d\n" , cbHeader ); 168
fprintf ( stderr , "dissect_wtp: offCur = %d\n" , offCur ); 169
------------------------------
63 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 236
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
proto_tree * hsrp_tree = NULL ; 114
guint8 type , len ; 115
if ( tree )  119
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 120
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 121
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
proto_tree * text_auth_tlv ; 224
gchar auth_buf [ 8 + 1 ] ; 225
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
------------------------------
64 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
65 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 231
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
proto_tree * hsrp_tree = NULL ; 112
guint8 type , len ; 113
if ( tree )  117
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 118
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 119
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
proto_tree * text_auth_tlv ; 219
gchar auth_buf [ 8 + 1 ] ; 220
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 222
offset += 2; 224
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 227
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
------------------------------
66 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
67 ../data/NVD/CVE_2012_5532_PATCHED_main.c strlen 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
68 ../data/NVD/CVE_2012_5532_VULN_main.c strlen 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
69 ../data/NVD/CVE_2012_6617_PATCHED_prepare_sdp_description.c strlen 45
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
* pbuffer = av_mallocz ( 2048 ); 36
return strlen ( * pbuffer ) ; 45
------------------------------
70 ../data/NVD/CVE_2012_6617_VULN_prepare_sdp_description.c strlen 43
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
* pbuffer = av_mallocz ( 2048 ); 34
return strlen ( * pbuffer ) ; 43
------------------------------
71 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 166
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
72 ../data/NVD/CVE_2012_5532_PATCHED_main.c free 147
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
free ( if_name ); 147
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
73 ../data/NVD/CVE_2012_5532_VULN_main.c free 160
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
74 ../data/NVD/CVE_2012_5532_VULN_main.c free 141
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
free ( if_name ); 141
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
75 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c strncpy 12
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
76 ../data/NVD/CVE_2013_0799_VULN_GetInstallationDir.c wcscpy 7
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
if ( argcTmp < 2 )  4
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
------------------------------
77 ../data/NVD/CVE_2013_0799_VULN_IsStatusApplying.c wcscpy 6
static BOOL
CVE_2013_0799_VULN_IsStatusApplying(LPCWSTR updateDirPath, BOOL &isApplying) 2
WCHAR updateStatusFilePath [ MAX_PATH + 1 ] ; 5
wcscpy ( updateStatusFilePath , updateDirPath ); 6
if ( ! PathAppendSafe ( updateStatusFilePath , L "update.status" ) ) 7
nsAutoHandle statusFile ( CreateFileW ( updateStatusFilePath , GENERIC_READ , FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 12
if ( INVALID_HANDLE_VALUE == statusFile )  18
if ( ! ReadFile ( statusFile , buf , sizeof ( buf ) , & read , NULL ) )  25
------------------------------
78 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
79 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
80 ../data/NVD/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
81 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
82 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
83 ../data/NVD/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
------------------------------
84 ../data/NVD/CVE_2012_6538_PATCHED_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
85 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
86 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 36
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
87 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 30
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
------------------------------
88 ../data/NVD/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 21
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
------------------------------
89 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 37
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
90 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 31
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
------------------------------
91 ../data/NVD/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 22
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
------------------------------
92 ../data/NVD/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memcpy 129
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  19
tun = __tun_get ( tfile ); 30
if ( cmd == TUNSETIFF && ! tun )  31
if ( ! tun )  45
switch ( cmd )  51
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 129
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 130
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  131
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 138
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 140
return ret ; 206
------------------------------
93 ../data/NVD/CVE_2012_6547_VULN___tun_chr_ioctl.c memcpy 127
static long CVE_2012_6547_VULN___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  17
tun = __tun_get ( tfile ); 28
if ( cmd == TUNSETIFF && ! tun )  29
if ( ! tun )  43
switch ( cmd )  49
if ( arg )  72
tun -> flags &= ~TUN_PERSIST; 75
tun -> owner = ( uid_t ) arg; 83
tun -> group = ( gid_t ) arg; 90
if ( tun -> dev -> flags & IFF_UP )  97
tun -> dev -> type = ( int ) arg; 102
tun -> debug = arg; 110
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 127
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 128
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  129
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 136
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 138
return ret ; 204
------------------------------
94 ../data/NVD/CVE_2013_0772_PATCHED_nsGIFDecoder2__OutputRow.c memcpy 66
uint32_t CVE_2013_0772_PATCHED_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  62
for (int r = drow_start; r <= drow_end; r++) 64
if ( r != int ( mGIFStruct . irow ) )  65
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 66
------------------------------
95 ../data/NVD/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c memcpy 74
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  70
for (int r = drow_start; r <= drow_end; r++) 72
if ( r != int ( mGIFStruct . irow ) )  73
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 74
------------------------------
96 ../data/NVD/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c memcpy 29
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* outString = temp; 22
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
------------------------------
97 ../data/NVD/CVE_2013_0782_VULN_nsSaveAsCharset__HandleFallBack.c memcpy 27
NS_IMETHODIMP
CVE_2013_0782_VULN_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + tempLen ) ; 16
if ( temp )  17
* outString = temp; 20
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 27
------------------------------
98 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c memcpy 287
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
99 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c memcpy 287
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
------------------------------
100 ../data/NVD/CVE_2013_0856_PATCHED_lpc_prediction.c memcpy 15
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
101 ../data/NVD/CVE_2013_0856_VULN_lpc_prediction.c memcpy 15
static void CVE_2013_0856_VULN_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
------------------------------
102 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 84
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
------------------------------
103 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 65
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
104 ../data/NVD/CVE_2012_5532_PATCHED_main.c close 45
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
105 ../data/NVD/CVE_2012_5532_VULN_main.c close 84
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
------------------------------
106 ../data/NVD/CVE_2012_5532_VULN_main.c close 65
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
------------------------------
107 ../data/NVD/CVE_2012_5532_VULN_main.c close 45
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
------------------------------
108 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strchr 22
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
109 ../data/NVD/CVE_2012_4530_VULN_load_script.c strchr 22
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
110 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 164
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
assert ( 0 && "unexpected colorspace" ); 164
------------------------------
111 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 139
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  137
assert ( 0 && "input type" ); 139
------------------------------
112 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 67
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  65
assert ( 0 && "input type" ); 67
------------------------------
113 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 37
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 35
if ( ! result )  36
assert ( 0 && "precacheLUT failed" ); 37
------------------------------
114 ../data/NVD/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
115 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 160
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
assert ( 0 && "unexpected colorspace" ); 160
------------------------------
116 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 135
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  133
assert ( 0 && "input type" ); 135
------------------------------
117 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 63
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  61
assert ( 0 && "input type" ); 63
------------------------------
118 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 33
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 31
if ( ! result )  32
assert ( 0 && "precacheLUT failed" ); 33
------------------------------
119 ../data/NVD/CVE_2013_0792_VULN_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
------------------------------
120 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 520
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
121 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 510
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
122 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 469
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
123 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 468
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
124 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 467
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
125 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 372
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
126 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 371
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
127 ../data/NVD/CVE_2013_0850_PATCHED_decode_slice_header.c assert 370
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
128 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 520
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
------------------------------
129 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 510
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
------------------------------
130 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 469
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
------------------------------
131 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 468
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
------------------------------
132 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 467
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
------------------------------
133 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 372
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
------------------------------
134 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 371
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
------------------------------
135 ../data/NVD/CVE_2013_0850_VULN_decode_slice_header.c assert 370
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
------------------------------
136 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 360
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 360
------------------------------
137 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 359
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 359
------------------------------
138 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 358
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr ); 358
------------------------------
139 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 261
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 261
------------------------------
140 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 260
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 260
------------------------------
141 ../data/NVD/CVE_2013_0867_PATCHED_decode_slice_header.c assert 259
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr ); 259
------------------------------
142 ../data/NVD/CVE_2012_5532_PATCHED_main.c malloc 114
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
143 ../data/NVD/CVE_2012_5532_VULN_main.c malloc 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
144 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
145 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
------------------------------
146 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 109
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
------------------------------
147 ../data/NVD/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
148 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 107
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
------------------------------
149 ../data/NVD/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
------------------------------
150 ../data/NVD/CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
151 ../data/NVD/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
152 ../data/NVD/CVE_2012_5532_PATCHED_main.c socket 31
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
switch ( op )  125
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
free ( if_name ); 166
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 223
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
strcpy ( key_name , "NetworkAddressIPv4" ); 234
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_value , os_build ); 242
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_value , os_name ); 246
strcpy ( key_name , "OSName" ); 247
strcpy ( key_value , os_major ); 250
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_value , os_minor ); 254
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_value , os_build ); 258
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_value , processor_arch ); 262
strcpy ( key_name , "ProcessorArchitecture" ); 263
len = netlink_send ( fd , incoming_cn_msg ); 281
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
153 ../data/NVD/CVE_2012_5532_VULN_main.c socket 31
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
switch ( op )  119
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 217
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
strcpy ( key_name , "NetworkAddressIPv4" ); 228
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_value , os_build ); 236
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_value , os_name ); 240
strcpy ( key_name , "OSName" ); 241
strcpy ( key_value , os_major ); 244
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_value , os_minor ); 248
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_value , os_build ); 252
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_value , processor_arch ); 256
strcpy ( key_name , "ProcessorArchitecture" ); 257
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
154 ../data/NVD/CVE_2012_4530_PATCHED_load_script.c strcpy 43
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
155 ../data/NVD/CVE_2012_4530_VULN_load_script.c strcpy 43
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
156 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 263
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
157 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 262
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
158 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 259
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
159 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 258
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
160 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 255
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
161 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 254
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
162 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 251
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
163 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 250
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
164 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 247
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
165 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 246
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
166 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 243
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
167 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 242
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
168 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 239
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
169 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 234
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
170 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 229
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 219
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_value , lic_version ); 229
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 232
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 237
strcpy ( key_value , os_build ); 242
strcpy ( key_value , os_name ); 246
strcpy ( key_value , os_major ); 250
strcpy ( key_value , os_minor ); 254
strcpy ( key_value , os_build ); 258
strcpy ( key_value , processor_arch ); 262
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
171 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 228
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
172 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 225
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 218
switch ( hv_msg -> body . kvp_enum_data . index )  221
strcpy ( key_name , "FullyQualifiedDomainName" ); 225
strcpy ( key_name , "IntegrationServicesVersion" ); 228
strcpy ( key_name , "NetworkAddressIPv4" ); 234
strcpy ( key_name , "NetworkAddressIPv6" ); 239
strcpy ( key_name , "OSBuildNumber" ); 243
strcpy ( key_name , "OSName" ); 247
strcpy ( key_name , "OSMajorVersion" ); 251
strcpy ( key_name , "OSMinorVersion" ); 255
strcpy ( key_name , "OSVersion" ); 259
strcpy ( key_name , "ProcessorArchitecture" ); 263
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
173 ../data/NVD/CVE_2012_5532_PATCHED_main.c strcpy 116
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( addr . nl_pid )  88
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 94
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 95
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 96
op = hv_msg -> kvp_hdr . operation; 103
pool = hv_msg -> kvp_hdr . pool; 104
hv_msg -> error = HV_S_OK; 105
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  107
in_hand_shake = 0; 112
p = ( char * ) hv_msg -> body . kvp_register . version; 113
lic_version = malloc ( strlen ( p ) + 1 ); 114
if ( lic_version )  115
strcpy ( lic_version , p ); 116
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 117
switch ( op )  125
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 127
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 128
if ( if_name == NULL )  131
hv_msg -> error = HV_E_FAIL; 136
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 139
if ( error )  144
hv_msg -> error = error; 145
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 151
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 152
if ( if_name == NULL )  154
hv_msg -> error = HV_GUID_NOTFOUND; 159
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 162
if ( error )  163
hv_msg -> error = error; 164
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  170
hv_msg -> error = HV_S_CONT; 175
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  179
hv_msg -> error = HV_S_CONT; 184
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  188
hv_msg -> error = HV_S_CONT; 191
if ( op != KVP_OP_ENUMERATE )  198
if ( pool != KVP_POOL_AUTO )  206
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  207
hv_msg -> error = HV_S_CONT; 213
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 217
switch ( hv_msg -> body . kvp_enum_data . index )  221
hv_msg -> error = HV_S_CONT; 266
incoming_cn_msg -> id . idx = CN_KVP_IDX; 276
incoming_cn_msg -> id . val = CN_KVP_VAL; 277
incoming_cn_msg -> ack = 0; 278
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 279
------------------------------
174 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 257
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
175 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 256
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
176 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 253
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
177 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 252
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
178 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 249
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
179 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 248
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
180 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 245
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
181 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 244
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
182 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 241
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
183 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 240
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
184 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 237
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
185 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 236
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
186 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 233
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
187 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 228
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
188 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 223
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
189 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 222
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
190 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 219
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
191 ../data/NVD/CVE_2012_5532_VULN_main.c strcpy 110
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
------------------------------
192 ../data/NVD/CVE_2012_6538_VULN_copy_to_user_auth.c strcpy 12
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
------------------------------
193 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c LoadLibraryW 32
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
systemDirectory [ systemDirLen + fileLen ] = L '\0' 27
systemDirectory [ MAX_PATH ] = L '\0' 29
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
194 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c LoadLibraryW 28
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 12
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
systemDirectory [ systemDirLen + fileLen ] = L '\0' 23
systemDirectory [ MAX_PATH ] = L '\0' 25
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
195 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 23
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
if ( systemDirLen + fileLen <= MAX_PATH )  26
------------------------------
196 ../data/NVD/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 12
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
------------------------------
197 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 19
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll"
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 4
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 18
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 19
if ( systemDirLen + fileLen <= MAX_PATH )  22
------------------------------
198 ../data/NVD/CVE_2013_0797_VULN_AutoLoadSystemDependencies.c wcslen 8
CVE_2013_0797_VULN_AutoLoadSystemDependencies() 1
size_t systemDirLen = wcslen ( systemDirectory ) ; 8
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 20
if ( systemDirLen + fileLen <= MAX_PATH )  22
LPCWSTR fullModulePath = systemDirectory ; 27
LoadLibraryW ( fullModulePath ); 28
------------------------------
199 ../data/NVD/CVE_2012_5532_PATCHED_main.c recvfrom 78
int CVE_2012_5532_PATCHED_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 )  81
if ( len < 0 )  282
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 283
------------------------------
200 ../data/NVD/CVE_2012_5532_VULN_main.c recvfrom 78
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
------------------------------
